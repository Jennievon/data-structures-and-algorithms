// Generated by CodiumAI

import { shortestPathToFinish } from ".";
import { GraphNode } from "../../../types";

/*
Code Analysis

Objective:
The objective of the function is to find the shortest path from a given starting node to all other nodes in a graph using breadth-first search algorithm.

Inputs:
The function takes in a single input parameter, which is a GraphNode representing the starting node of the graph.

Flow:
The function initializes a Map to store the distances of each node from the starting node, a Set to keep track of visited nodes, and a queue to store nodes to be visited. It then sets the distance of the starting node to 0 and adds it to the queue. While the queue is not empty, the function dequeues a node, adds it to the visited set, and iterates through its neighbors. For each neighbor, if it has not been visited, it is added to the queue. The function then calculates the distance of the neighbor from the starting node and updates its distance in the Map if it is shorter than the current distance.

Outputs:
The main output of the function is a Map containing the shortest distances of each node from the starting node.

Additional aspects:
- The function uses breadth-first search algorithm to traverse the graph.
- The function assumes that the graph is connected, i.e., there is a path between any two nodes in the graph.
- The function does not return the actual shortest path, only the distances.
*/

describe("shortestPathToFinish_function", () => {
  // Tests that the function returns the correct shortest path for a graph with multiple nodes and edges
  it("test_shortest_path_multiple_nodes", () => {
    const node1 = new GraphNode(1);
    const node2 = new GraphNode(2);
    const node3 = new GraphNode(3);
    const node4 = new GraphNode(4);
    const node5 = new GraphNode(5);

    node1.neighbors.push(node2, node3);
    node2.neighbors.push(node4);
    node3.neighbors.push(node4, node5);

    const result = shortestPathToFinish(node1);

    expect(result.get(node1)).toBe(0);
    expect(result.get(node2)).toBe(1);
    expect(result.get(node3)).toBe(1);
    expect(result.get(node4)).toBe(2);
    expect(result.get(node5)).toBe(2);
  });

  // Tests that the function returns the correct shortest path for a graph with only one node
  it("test_shortest_path_one_node", () => {
    const node1 = new GraphNode(1);

    const result = shortestPathToFinish(node1);

    expect(result.get(node1)).toBe(0);
  });

  // Tests that the function returns the correct shortest path for a graph with no edges
  it("test_shortest_path_no_edges", () => {
    const node1 = new GraphNode(1);
    const node2 = new GraphNode(2);

    const result = shortestPathToFinish(node1);

    expect(result.get(node1)).toBe(0);
    expect(result.get(node2)).toBeUndefined();
  });

  // Tests that the function returns the correct shortest path for a graph with cycles
  it("test_shortest_path_cycles", () => {
    const node1 = new GraphNode(1);
    const node2 = new GraphNode(2);
    const node3 = new GraphNode(3);

    node1.neighbors.push(node2);
    node2.neighbors.push(node3);
    node3.neighbors.push(node1);

    const result = shortestPathToFinish(node1);

    expect(result.get(node1)).toBe(0);
    expect(result.get(node2)).toBe(1);
    expect(result.get(node3)).toBe(1);
  });

  // Tests that the function returns the correct shortest path for a graph with disconnected nodes
  it("test_shortest_path_disconnected_nodes", () => {
    const node1 = new GraphNode(1);
    const node2 = new GraphNode(2);
    const node3 = new GraphNode(3);

    node1.neighbors.push(node2);
    node3.neighbors.push(node3);

    const result = shortestPathToFinish(node1);

    expect(result.get(node1)).toBe(0);
    expect(result.get(node2)).toBe(1);
    expect(result.get(node3)).toBeUndefined();
  });

  // Tests that the function returns the correct shortest path for a graph with negative edge weights
  it("test_shortest_path_negative_edge_weights", () => {
    const node1 = new GraphNode(1);
    const node2 = new GraphNode(2);
    const node3 = new GraphNode(3);

    node1.neighbors.push(node2);
    node2.neighbors.push(node3);
    node3.neighbors.push(node1, node2);

    const result = shortestPathToFinish(node1);

    expect(result.get(node1)).toBe(0);
    expect(result.get(node2)).toBe(-Infinity);
    expect(result.get(node3)).toBe(-Infinity);
  });
});
